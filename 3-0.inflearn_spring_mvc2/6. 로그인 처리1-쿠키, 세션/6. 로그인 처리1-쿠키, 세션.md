# 로그인 처리1-쿠키, 세션

### 로그인 요구사항

- 홈 화면 - 로그인 전

    → 회원 가입

    → 로그인

- 홈 화면 - 로그인 후

    → 본인 이름(누구님 환영합니다.)

    → 상품 관리

    → 로그 아웃

- 보안 요구사항

    → 로그인 사용자만 상품에 접근하고, 관리할 수 있음

    → 로그인 하지 않은 사용자가 상품 관리에 접근하면 로그인 화면으로 이동

- 회원 가입, 상품 관리

--- 

### 프로젝트 생성

### 프로젝트 생성

cf) 패키지 구조 설계

```yaml
package 구조
hello.login
	- domain
		- item
		- member
		- login
	- web
		- item
		- member
		- login
```

→ 도메인이 가장 중요함

→ 여기서 말하는 도메인 = 화면, UI, 기술 인프라 등등의 영역은 제외한 시스템이 구현해야 하는 핵심 비즈니스 업무 영역을 말함

→ 향후 web을 다른 기술로 바꾸어도 도메인은 그대로 유지할 수 있어야 함.

→ 이렇게 하려면 web은 domain을 알고있지만 domain은 web을 모르도록 설계해야 함.

---

### 홈 화면

- 홈 화면 개발

    → HomeController.java

    → templates/home.html

- github 실습 코드 참고

---

### 회원 가입

- 회원가입 기능, 페이지 구현

- github 실습 코드 참고

---

### 로그인 기능

- 로그인 기능 개발

- github 실습 코드 참고

---

### 로그인 처리하기 - 쿠키 사용

- 쿠키를 사용해 로그인, 로그아웃 기능 개발

- 쿠키에는 영속 쿠키와 세션 쿠키가 있음

    → 영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유지

    → 세션 쿠키: 만료 날짜를 생략하면 브라우저 종료시 까지만 유지

- github 실습 코드 참고

---

### 쿠키와 보안 문제

- 보안 문제

    → 쿠키 값은 임의로 변경할 수 있음

    → 쿠키에 보관된 정보는 훔쳐갈 수 있음

    → 해커가 쿠키를 한번 훔쳐가면 평생 사용할 수 있음

- 대안

    → 쿠키에 중요한 값을 노출하지 않고, 사용자 별로 예측 불가능한 임의의 토큰(랜덤 값)을 노출하고, 서버에서 토큰과 사용자 id를 매핑해서 인식함. 그리고 서버에서 토큰을 관리함.

    → 토큰은 해커가 임의의 값을 넣어도 찾을 수 없도록 예상 불가능 해야 함

    → 해커가 토큰을 털어가도 시간이 지나면 사용할 수 없도록 서버에서 해당 토큰의 만료시간을 짧게(예: 30분) 유지함. 또는 해킹이 의심되는 경우 서버에서 해당 토큰을 강제로 제거하면 됨.

---

### 로그인 처리하기 - 세션 동작 방식

- 세션 동작 방식
1. 로그인

    → 사용자가 loginId, password 정보를 전달하면 서버에서 해당 사용자가 맞는지 확인함

2. 세션 생성

    → 세션 ID를 생성하는데, 추정 불가능해야 함

    → UUID는 추정이 불가능함

    → 생성된 세션 ID와 세션에 보관할 값( memberA )을 서버의 세션 저장소에 보관함

3. 세션id를 응답 쿠키로 전달

    → 서버는 클라이언트에 mySessionId 라는 이름으로 세션ID 만 쿠키에 담아서 전달함

    → 클라이언트는 쿠키 저장소에 mySessionId 쿠키를 보관함

    → 여기서 중요한 포인트는 회원과 관련된 정보는 전혀 클라이언트에 전달하지 않는다는 것임. 오직 추정 불가능한 세션 ID만 쿠키를 통해 클라이언트에 전달함.

4. 클라이언트의 세션id 쿠키 전달

    → 클라이언트는 요청시 항상 mySessionId 쿠키를 전달함.

    → 서버에서는 클라이언트가 전달한 mySessionId 쿠키 정보로 세션 저장소를 조회해서 로그인시 보관한 세션 정보를 사용함

---

### 로그인 처리하기 - 세션 직접 만들기

- github 실습 코드 참고

---

### 로그인 처리하기 - 직접 만든 세션 적용

- github 실습 코드 참고

- 세션이라는 것은 뭔가 특별한 것이 아니라 단지 쿠키를 사용하는데, 서버에서 데이터를 유지하는 방법임

---

### 로그인 처리하기 - 서블릿 HTTP 세션1

- 서블릿이 제공하는 HttpSession도 결국 우리가 앞에서 만든 SessionManager과 같은 방식으로 동작함

- 서블릿을 통해 HttpSession을 생성하면 다음과 같은 쿠키를 생성함. 쿠키 이름이 JSESSIONID이고, 값은 추정 불가능한 랜덤 값임

- 세션 생성과 조회

    → `request.getSession(true)` (default값)

    : 세션이 있으면 기존 세션을 반환함

    : 세션이 없으면 새로운 세션을 생성해서 반환함

    → `request.getSession(false)`

    : 세션이 있으면 기존 세션을 반환함

    : 세션이 없으면 새로운 세션을 생성하지 않음. null을 반환함

- github 실습 코드 참고

---

### 로그인 처리하기 - 서블릿 HTTP 세션2

- `@SessionAttribute`

    → 이 기능은 세션을 생성하지는 않고, 조회할 때 사용

    ```java
    @SessionAttribute(name = "loginMember", required = false) Member loginMember
    ```

- github 실습 코드 참고

- URL 전달 방식을 끄고 항상 쿠키를 통해서만 세션을 유지하고 싶은 경우 아래와 같이 설정함

    ```xml
    //application.properties
    server.servlet.session.tracking-modes=cookie
    ```

---

### 세션 정보와 타임아웃 설정

- 세션 정보 확인

    → `sessionId` : 세션Id, JSESSIONID 의 값

    예) 34B14F008AA3527C9F8ED620EFD7A4E1

    → `maxInactiveInterval` : 세션의 유효 시간, 예) 1800초, (30분)

    → `creationTime` : 세션 생성일시

    → `lastAccessedTime` : 세션과 연결된 사용자가 최근에 서버에 접근한 시간, 클라이언트에서 서버로 `sessionId ( JSESSIONID )`를 요청한 경우에 갱신됨

    → `isNew` : 새로 생성된 세션인지, 아니면 이미 과거에 만들어졌고, 클라이언트에서 서버로 `sessionId( JSESSIONID )`를 요청해서 조회된 세션인지 여부

- 세션 타임아웃 설정

    → 세션은 사용자가 로그아웃을 직접 호출해서 `session.invalidate()` 가 호출 되는 경우에 삭제됨

    → 그런데 대부분의 사용자는 로그아웃을 선택하지 않고, 그냥 웹 브라우저를 종료함

    → 이럴 경우 서버에서 세션 데이터를 언제 삭제해야 하는지 판단 어려움

    → 세션 종료 시점은 어떻게??

    : 사용자가 서버에 최근에 요청한 시간을 기준으로 30분 정도 유지하는 방식

---

### 정리 및 회고

- 이번 파트에서는 로그인 처리하는 방법을 공부하며 쿠키에 사용자 정보를 저장했을 때의 위험성과 이를 보완하기 위해 세션을 이용하는 방법에 대해 학습하였다.

- 이전에 사이드 프로젝트를 할 때는 세션을 이용하면 서버에 부담이 많이가 jwt를 사용하였었다. 이떄 jwt도 토큰 탈취 보안 문제로 인해 refresh token을 생성하고 했었다. 

- 세션 같은 경우 타임아웃을 설정함으로써 세션 탈취로부터 보안을 강화하는데 이것만 설정함으로써 보안을 강화할 수 있는 건가?? 이 부분에 대해서는 더 찾아봐야겠다.

---